#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/mman.h>
#include <netinet/in.h>

void print_addresses()
{
    printf("Here is the list of symbols that Scout needs for the embedded PIC context:\n");
    printf("symbol_memcpy  \t\t= %p\n", memcpy);
    printf("symbol_memset  \t\t= %p\n", memset);
    printf("symbol_malloc  \t\t= %p\n", malloc);
    printf("symbol_free    \t\t= %p\n", free);
    printf("symbol_socket  \t\t= %p\n", socket);
    printf("symbol_bind    \t\t= %p\n", bind);
    printf("symbol_listen  \t\t= %p\n", listen);
    printf("symbol_accept  \t\t= %p\n", accept);
    printf("symbol_connect \t\t= %p\n", connect);
    printf("symbol_recv    \t\t= %p\n", recv);
    printf("symbol_send    \t\t= %p\n", send);
    printf("symbol_close   \t\t= %p\n", close);
    printf("symbol_mmap    \t\t= %p\n", mmap);
    printf("symbol_mprotect\t\t= %p\n", mprotect);
    printf("symbol_munmap  \t\t= %p\n", munmap);
}

void load_and_execute(char * path)
{
    struct stat fileStat;
    int fd = open(path, O_RDONLY);
    /* Open the file */
    if(fd == -1)
    {
        printf("Invalid path: \"%s\", failed to open the file\n", path);
        return;
    }

    /* Get the file's size */
    if(fstat(fd, &fileStat) < 0)
    {
        printf("Failed to fstat() the file, used to calculate the file's size\n");
        close(fd);
        return;
    }

    /* Allocate a buffer for the entire file */
    char * buffer = (char *)mmap(NULL, fileStat.st_size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if((ssize_t)buffer == -1)
    {
        printf("Failed to allocate a buffer for the file, size was: 0x%x\n", (unsigned int)fileStat.st_size);
        goto free_resources;
    }

    /* Read the entire content to the buffer */
    if(read(fd, buffer, fileStat.st_size) != fileStat.st_size)
    {
        printf("Failed to read the entire file content\n");
        goto free_resources;
    }

    /* Map it to be executable */
    mprotect(buffer, fileStat.st_size, PROT_READ | PROT_WRITE | PROT_EXEC);

    /* We might be running on a native Arm machine, we need to clear the cache */
    sleep(1);

    /* Jump into this buffer */
    ((void (*)(void))buffer)();

free_resources:
    /* clean up (probably won't happen) */
    munmap(buffer, fileStat.st_size);
    close(fd);

    return;
}

void print_usage(char * path)
{
    printf("Usage: %s <embedded binary blob.bin>\n", path);
}

int main(int argc, char** argv)
{
    /* Check the number of arguments */
    if(argc != 1 + 1)
    {
        printf("Wrong amount of arguments, got %d and expected %d\n", argc - 1, 1);
        print_usage(argv[0]);
        exit(1);
    }

    char * path = argv[1];

    /* First, print the addresses to the user */
    print_addresses();

    /* Second, wait for the user's approval */
    printf("Press ENTER to continue (loading and executing the file)\n");
    fgetc(stdin);

    /* Last, load this blob, and jump into it */
    load_and_execute(path);

    printf("Should not reach this print line...\n");
    return 0;
}
